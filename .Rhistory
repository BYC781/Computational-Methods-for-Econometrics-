ep.g <- S.g %*% Y.g - XX.g %*% beta - l.g*a.g
return(t(ep.g)%*%ep.g)
}) %>% sum()
sigma2_T[t] <- rinvgamma(1, (k_0 + sum(N))/2, (v_0+ sum_ep.gTep.g)/2)
# THE SAMPLING OF ALPHA_G FROM PROSTERIOR DISTRIBUTION
sigma2 <- sigma2_T[t]
l.g <- rep(1, N[g])
S.g <- diag(N[g]) - lambda_T[t] * W[[g]] %>% as.matrix()
Y.g <- Y[[g]]
beta <- beta_T[t,]
cbind(X[[g]], W[[g]]%*%X[[g]])
R.g <- (A_0^-1 + sigma2^-1 * t(l.g) %*% l.g) ^-1
a.g_hat <- R.g * (A_0^-1 * a_0 + sigma2^-1 * t(l.g)%*%(S.g%*%Y.g-XX.g%*%beta))
alpha_T[t, ] <- rnorm(76, a.g_hat, R.g)
}
# propose lambda*
for (t in 2:T){
accept = 0
while (accept == 0){
if (t<=2){
lambda_prime <- mvrnorm(mu = lambda_T[t-1], Sigma = 0.1^2 * diag(1))
}else{
lambda_prime <- mvrnorm(mu = lambda_T[t-1], Sigma = 2.38^2 * var(lambda_T[1:t-1])) * 0.95 +mvrnorm(mu = lambda_T[t-1], Sigma = 0.1^2 * diag(1)) * 0.05
}
accept = ifelse(lambda_prime >= -1/tao_G && lambda_prime <= 1/tao_G, 1, 0)
}
pp_l = 0
for (g in 1:76){
S_1 <- diag(N[g]) - lambda_prime * W[[g]] %>% as.matrix()
S_2 <- diag(N[g]) - lambda_T[t-1] * W[[g]] %>% as.matrix()
XX.g <- cbind(X[[g]], W[[g]]%*%X[[g]])
ep_1 <- S_1 %*% Y[[g]] - XX.g %*% beta_T[t-1, ] - rep(1, N[g]) * alpha_T[t-1, g]
ep_2 <- S_2 %*% Y[[g]] - XX.g %*% beta_T[t-1, ] - rep(1, N[g]) * alpha_T[t-1, g]
V = sigma2_T[t-1] * diag(N[g])
like_1 <- log(det(S_1)) - 0.5 * t(ep_1) %*% solve(V) %*% ep_1
like_2 <- log(det(S_2)) - 0.5 * t(ep_2) %*% solve(V) %*% ep_2
pp_l = pp_l + like_1 - like_2
}
pp_l = min(c(exp(pp_l), 1))
lambda_T[t] = ifelse(runif(1) <= pp_l, lambda_prime, lambda_T[t-1])
# THE SAMPLING OF BETA FROM PROSTERIOR DISTRIBUTION
B <- lapply(1:76, function(g){
XX.g <- cbind(X[[g]], W[[g]]%*%X[[g]])
return(t(XX.g) %*% XX.g)
})
B <- Reduce("+", B)
B <- solve(solve(B_0) + B)
beta_hat <- lapply(1:76, function(g){
sigma2 <- sigma2_T[t-1]
S.g <- diag(N[g]) - lambda_T[t] * W[[g]] %>% as.matrix()
XX.g <- cbind(X[[g]], W[[g]]%*%X[[g]])
Y.g <- Y[[g]]
l.g <- rep(1, N[g])
a.g <- alpha_T[t-1]
return(sigma2^-1 * t(XX.g) %*% (S.g%*%Y.g - l.g*a.g))
})
beta_hat <- Reduce("+", beta_hat)
beta_hat <- B %*% (solve(B_0)%*%b_0 + beta_hat)
beta_T[t,] <- mvrnorm(n=1, mu=beta_hat, Sigma=B)
# THE SAMPLING OF SIGMA_E^2 FROM PROSTERIOR DISTRIBUTION
sum_ep.gTep.g <- sapply(1:76, function(g){
S.g <- diag(N[g]) - lambda_T[t] * W[[g]] %>% as.matrix()
Y.g <- Y[[g]]
XX.g <- cbind(X[[g]], W[[g]]%*%X[[g]])
l.g <- rep(1, N[g])
a.g <- alpha_T[t-1]
beta <- beta_T[t,]
ep.g <- S.g %*% Y.g - XX.g %*% beta - l.g*a.g
return(t(ep.g)%*%ep.g)
}) %>% sum()
sigma2_T[t] <- rinvgamma(1, (k_0 + sum(N))/2, (v_0+ sum_ep.gTep.g)/2)
# THE SAMPLING OF ALPHA_G FROM PROSTERIOR DISTRIBUTION
sigma2 <- sigma2_T[t]
l.g <- rep(1, N[g])
S.g <- diag(N[g]) - lambda_T[t] * W[[g]] %>% as.matrix()
Y.g <- Y[[g]]
beta <- beta_T[t,]
cbind(X[[g]], W[[g]]%*%X[[g]])
R.g <- (A_0^-1 + sigma2^-1 * t(l.g) %*% l.g) ^-1
a.g_hat <- R.g * (A_0^-1 * a_0 + sigma2^-1 * t(l.g)%*%(S.g%*%Y.g-XX.g%*%beta))
alpha_T[t, ] <- rnorm(76, a.g_hat, R.g)
}
posterior_result <- list()
posterior_result$alpha_mean <- sapply(1:76, function(g){mean(alpha_T[,g])})
posterior_result$alpha_sd <- sapply(1:76, function(g){sd(alpha_T[,g])})
posterior_result$beta_mean <- sapply(1:34, function(k){mean(beta_T[,k])})
posterior_result$beta_sd <- sapply(1:34, function(k){sd(beta_T[,k])})
posterior_result$lambda_mean <- mean(lambda_T)
posterior_result$lambda_sd <- sd(lambda_T)
posterior_result$sigma2_mean <- mean(sigma2_T)
posterior_result$sigma2_sd <- sd(sigma2_T)
var.name <- c("lambda", paste0("b1.", 1:17), paste0("b2.", 1:17), paste0("a", 1:76), "sigma2")
var.mean <- c(posterior_result$lambda_mean, posterior_result$beta_mean,
posterior_result$alpha_mean, posterior_result$lambda_mean)
var.sd <- c(posterior_result$lambda_sd, posterior_result$beta_sd,
posterior_result$alpha_sd, posterior_result$lambda_sd)
df <- data.frame(cbind(var.name, var.mean, var.sd))
kable(df)
mean(sigma2_T)
var.name <- c("lambda", paste0("b1.", 1:17), paste0("b2.", 1:17), paste0("a", 1:76), "sigma2")
var.mean <- c(posterior_result$lambda_mean, posterior_result$beta_mean,
posterior_result$alpha_mean, posterior_result$sigma2_mean)
var.sd <- c(posterior_result$lambda_sd, posterior_result$beta_sd,
posterior_result$alpha_sd, posterior_result$sigma2_sd)
df <- data.frame(cbind(var.name, var.mean, var.sd))
kable(df)
T = 20000 # number of iterations during Markov process
# assign param in prior distribution
# beta k = 17 so 2k = 34
b_0 <- rep(0, 34)
B_0 <- diag(1, 34, 34)
# alpha
a_0 <- 5; A_0 <- 0.1
# sigma2
k_0 <- 3; v_0 <- 3
lambda_prime = 0
# saver
lambda_T <- rep(NA, T)
beta_T <- matrix(nrow = T, ncol = 34)
alpha_T <- matrix(nrow = T, ncol = 76)
sigma2_T <- rep(NA, T)
# starting value of draw
tao_G = sapply(1:76, function(g){W[[g]] %>% rowSums() %>% max()}) %>% max()
lambda_T[1] <- 0.0397
beta_T[1,] <- c(-0.1845, rep(0, 33))
alpha_T[1,] <- rep(5, 76)
sigma2_T[1] <- 0.5
# propose lambda*
for (t in 2:T){
accept = 0
while (accept == 0){
if (t<=2){
lambda_prime <- mvrnorm(mu = lambda_T[t-1], Sigma = 0.1^2 * diag(1))
}else{
lambda_prime <- mvrnorm(mu = lambda_T[t-1], Sigma = 2.38^2 * var(lambda_T[1:t-1])) * 0.95 +mvrnorm(mu = lambda_T[t-1], Sigma = 0.1^2 * diag(1)) * 0.05
}
accept = ifelse(lambda_prime >= -1/tao_G && lambda_prime <= 1/tao_G, 1, 0)
}
pp_l = 0
for (g in 1:76){
S_1 <- diag(N[g]) - lambda_prime * W[[g]] %>% as.matrix()
S_2 <- diag(N[g]) - lambda_T[t-1] * W[[g]] %>% as.matrix()
XX.g <- cbind(X[[g]], W[[g]]%*%X[[g]])
ep_1 <- S_1 %*% Y[[g]] - XX.g %*% beta_T[t-1, ] - rep(1, N[g]) * alpha_T[t-1, g]
ep_2 <- S_2 %*% Y[[g]] - XX.g %*% beta_T[t-1, ] - rep(1, N[g]) * alpha_T[t-1, g]
V = sigma2_T[t-1] * diag(N[g])
like_1 <- log(det(S_1)) - 0.5 * t(ep_1) %*% solve(V) %*% ep_1
like_2 <- log(det(S_2)) - 0.5 * t(ep_2) %*% solve(V) %*% ep_2
pp_l = pp_l + like_1 - like_2
}
pp_l = min(c(exp(pp_l), 1))
lambda_T[t] = ifelse(runif(1) <= pp_l, lambda_prime, lambda_T[t-1])
# THE SAMPLING OF BETA FROM PROSTERIOR DISTRIBUTION
B <- lapply(1:76, function(g){
XX.g <- cbind(X[[g]], W[[g]]%*%X[[g]])
return(t(XX.g) %*% XX.g)
})
B <- Reduce("+", B)
B <- solve(solve(B_0) + B)
beta_hat <- lapply(1:76, function(g){
sigma2 <- sigma2_T[t-1]
S.g <- diag(N[g]) - lambda_T[t] * W[[g]] %>% as.matrix()
XX.g <- cbind(X[[g]], W[[g]]%*%X[[g]])
Y.g <- Y[[g]]
l.g <- rep(1, N[g])
a.g <- alpha_T[t-1]
return(sigma2^-1 * t(XX.g) %*% (S.g%*%Y.g - l.g*a.g))
})
beta_hat <- Reduce("+", beta_hat)
beta_hat <- B %*% (solve(B_0)%*%b_0 + beta_hat)
beta_T[t,] <- mvrnorm(n=1, mu=beta_hat, Sigma=B)
# THE SAMPLING OF SIGMA_E^2 FROM PROSTERIOR DISTRIBUTION
sum_ep.gTep.g <- sapply(1:76, function(g){
S.g <- diag(N[g]) - lambda_T[t] * W[[g]] %>% as.matrix()
Y.g <- Y[[g]]
XX.g <- cbind(X[[g]], W[[g]]%*%X[[g]])
l.g <- rep(1, N[g])
a.g <- alpha_T[t-1]
beta <- beta_T[t,]
ep.g <- S.g %*% Y.g - XX.g %*% beta - l.g*a.g
return(t(ep.g)%*%ep.g)
}) %>% sum()
sigma2_T[t] <- rinvgamma(1, (k_0 + sum(N))/2, (v_0+ sum_ep.gTep.g)/2)
# THE SAMPLING OF ALPHA_G FROM PROSTERIOR DISTRIBUTION
sigma2 <- sigma2_T[t]
l.g <- rep(1, N[g])
S.g <- diag(N[g]) - lambda_T[t] * W[[g]] %>% as.matrix()
Y.g <- Y[[g]]
beta <- beta_T[t,]
cbind(X[[g]], W[[g]]%*%X[[g]])
R.g <- (A_0^-1 + sigma2^-1 * t(l.g) %*% l.g) ^-1
a.g_hat <- R.g * (A_0^-1 * a_0 + sigma2^-1 * t(l.g)%*%(S.g%*%Y.g-XX.g%*%beta))
alpha_T[t, ] <- rnorm(76, a.g_hat, R.g)
}
posterior_result <- list()
posterior_result$alpha_mean <- sapply(1:76, function(g){mean(alpha_T[,g])})
posterior_result$alpha_sd <- sapply(1:76, function(g){sd(alpha_T[,g])})
posterior_result$beta_mean <- sapply(1:34, function(k){mean(beta_T[,k])})
posterior_result$beta_sd <- sapply(1:34, function(k){sd(beta_T[,k])})
posterior_result$lambda_mean <- mean(lambda_T)
posterior_result$lambda_sd <- sd(lambda_T)
posterior_result$sigma2_mean <- mean(sigma2_T)
posterior_result$sigma2_sd <- sd(sigma2_T)
var.name <- c("lambda", paste0("b1.", 1:17), paste0("b2.", 1:17), paste0("a", 1:76), "sigma2")
var.mean <- c(posterior_result$lambda_mean, posterior_result$beta_mean,
posterior_result$alpha_mean, posterior_result$sigma2_mean)
var.sd <- c(posterior_result$lambda_sd, posterior_result$beta_sd,
posterior_result$alpha_sd, posterior_result$sigma2_sd)
df <- data.frame(cbind(var.name, var.mean, var.sd))
kable(df)
# propose lambda*
for (t in 2:T){
accept = 0
while (accept == 0){
if (t<2){
lambda_prime <- mvrnorm(mu = lambda_T[t-1], Sigma = 0.1^2 * diag(1))
}else{
lambda_prime <- mvrnorm(mu = lambda_T[t-1], Sigma = 2.38^2 * var(lambda_T[1:t-1])) * 0.95 +mvrnorm(mu = lambda_T[t-1], Sigma = 0.1^2 * diag(1)) * 0.05
}
accept = ifelse(lambda_prime >= -1/tao_G && lambda_prime <= 1/tao_G, 1, 0)
}
pp_l = 0
for (g in 1:76){
S_1 <- diag(N[g]) - lambda_prime * W[[g]] %>% as.matrix()
S_2 <- diag(N[g]) - lambda_T[t-1] * W[[g]] %>% as.matrix()
XX.g <- cbind(X[[g]], W[[g]]%*%X[[g]])
ep_1 <- S_1 %*% Y[[g]] - XX.g %*% beta_T[t-1, ] - rep(1, N[g]) * alpha_T[t-1, g]
ep_2 <- S_2 %*% Y[[g]] - XX.g %*% beta_T[t-1, ] - rep(1, N[g]) * alpha_T[t-1, g]
V = sigma2_T[t-1] * diag(N[g])
like_1 <- log(det(S_1)) - 0.5 * t(ep_1) %*% solve(V) %*% ep_1
like_2 <- log(det(S_2)) - 0.5 * t(ep_2) %*% solve(V) %*% ep_2
pp_l = pp_l + like_1 - like_2
}
pp_l = min(c(exp(pp_l), 1))
lambda_T[t] = ifelse(runif(1) <= pp_l, lambda_prime, lambda_T[t-1])
# THE SAMPLING OF BETA FROM PROSTERIOR DISTRIBUTION
B <- lapply(1:76, function(g){
XX.g <- cbind(X[[g]], W[[g]]%*%X[[g]])
return(t(XX.g) %*% XX.g)
})
B <- Reduce("+", B)
B <- solve(solve(B_0) + B)
beta_hat <- lapply(1:76, function(g){
sigma2 <- sigma2_T[t-1]
S.g <- diag(N[g]) - lambda_T[t] * W[[g]] %>% as.matrix()
XX.g <- cbind(X[[g]], W[[g]]%*%X[[g]])
Y.g <- Y[[g]]
l.g <- rep(1, N[g])
a.g <- alpha_T[t-1]
return(sigma2^-1 * t(XX.g) %*% (S.g%*%Y.g - l.g*a.g))
})
beta_hat <- Reduce("+", beta_hat)
beta_hat <- B %*% (solve(B_0)%*%b_0 + beta_hat)
beta_T[t,] <- mvrnorm(n=1, mu=beta_hat, Sigma=B)
# THE SAMPLING OF SIGMA_E^2 FROM PROSTERIOR DISTRIBUTION
sum_ep.gTep.g <- sapply(1:76, function(g){
S.g <- diag(N[g]) - lambda_T[t] * W[[g]] %>% as.matrix()
Y.g <- Y[[g]]
XX.g <- cbind(X[[g]], W[[g]]%*%X[[g]])
l.g <- rep(1, N[g])
a.g <- alpha_T[t-1]
beta <- beta_T[t,]
ep.g <- S.g %*% Y.g - XX.g %*% beta - l.g*a.g
return(t(ep.g)%*%ep.g)
}) %>% sum()
sigma2_T[t] <- rinvgamma(1, (k_0 + sum(N))/2, (v_0+ sum_ep.gTep.g)/2)
# THE SAMPLING OF ALPHA_G FROM PROSTERIOR DISTRIBUTION
sigma2 <- sigma2_T[t]
l.g <- rep(1, N[g])
S.g <- diag(N[g]) - lambda_T[t] * W[[g]] %>% as.matrix()
Y.g <- Y[[g]]
beta <- beta_T[t,]
cbind(X[[g]], W[[g]]%*%X[[g]])
R.g <- (A_0^-1 + sigma2^-1 * t(l.g) %*% l.g) ^-1
a.g_hat <- R.g * (A_0^-1 * a_0 + sigma2^-1 * t(l.g)%*%(S.g%*%Y.g-XX.g%*%beta))
alpha_T[t, ] <- rnorm(76, a.g_hat, R.g)
}
# starting value of draw
tao_G = sapply(1:76, function(g){W[[g]] %>% rowSums() %>% max()}) %>% max()
lambda_T[1] <- 0.0397
beta_T[1,] <- c(-0.1845, rep(0, 33))
alpha_T[1,] <- rep(5, 76)
sigma2_T[1] <- 1
rnorm(1,1,0)
var(lambda_T[1:t-1]))
t=1
t=2
var(lambda_T[1:t-1])
mvrnorm(mu = lambda_T[t-1], Sigma = 0))
mvrnorm(mu = lambda_T[t-1], Sigma = 0))
mvrnorm(mu = lambda_T[t-1], Sigma = 0)
# propose lambda*
for (t in 2:T){
accept = 0
while (accept == 0){
if (t<2){
lambda_prime <- mvrnorm(mu = lambda_T[t-1], Sigma = 0.1^2 * diag(1))
}else if(t == 2){
lambda_prime <- mvrnorm(mu = lambda_T[t-1], Sigma = 0) * 0.95 +mvrnorm(mu = lambda_T[t-1], Sigma = 0.1^2 * diag(1)) * 0.05
}else{
lambda_prime <- mvrnorm(mu = lambda_T[t-1], Sigma = 2.38^2 * var(lambda_T[1:t-1])) * 0.95 +mvrnorm(mu = lambda_T[t-1], Sigma = 0.1^2 * diag(1)) * 0.05
}
accept = ifelse(lambda_prime >= -1/tao_G && lambda_prime <= 1/tao_G, 1, 0)
}
pp_l = 0
for (g in 1:76){
S_1 <- diag(N[g]) - lambda_prime * W[[g]] %>% as.matrix()
S_2 <- diag(N[g]) - lambda_T[t-1] * W[[g]] %>% as.matrix()
XX.g <- cbind(X[[g]], W[[g]]%*%X[[g]])
ep_1 <- S_1 %*% Y[[g]] - XX.g %*% beta_T[t-1, ] - rep(1, N[g]) * alpha_T[t-1, g]
ep_2 <- S_2 %*% Y[[g]] - XX.g %*% beta_T[t-1, ] - rep(1, N[g]) * alpha_T[t-1, g]
V = sigma2_T[t-1] * diag(N[g])
like_1 <- log(det(S_1)) - 0.5 * t(ep_1) %*% solve(V) %*% ep_1
like_2 <- log(det(S_2)) - 0.5 * t(ep_2) %*% solve(V) %*% ep_2
pp_l = pp_l + like_1 - like_2
}
pp_l = min(c(exp(pp_l), 1))
lambda_T[t] = ifelse(runif(1) <= pp_l, lambda_prime, lambda_T[t-1])
# THE SAMPLING OF BETA FROM PROSTERIOR DISTRIBUTION
B <- lapply(1:76, function(g){
XX.g <- cbind(X[[g]], W[[g]]%*%X[[g]])
return(t(XX.g) %*% XX.g)
})
B <- Reduce("+", B)
B <- solve(solve(B_0) + B)
beta_hat <- lapply(1:76, function(g){
sigma2 <- sigma2_T[t-1]
S.g <- diag(N[g]) - lambda_T[t] * W[[g]] %>% as.matrix()
XX.g <- cbind(X[[g]], W[[g]]%*%X[[g]])
Y.g <- Y[[g]]
l.g <- rep(1, N[g])
a.g <- alpha_T[t-1]
return(sigma2^-1 * t(XX.g) %*% (S.g%*%Y.g - l.g*a.g))
})
beta_hat <- Reduce("+", beta_hat)
beta_hat <- B %*% (solve(B_0)%*%b_0 + beta_hat)
beta_T[t,] <- mvrnorm(n=1, mu=beta_hat, Sigma=B)
# THE SAMPLING OF SIGMA_E^2 FROM PROSTERIOR DISTRIBUTION
sum_ep.gTep.g <- sapply(1:76, function(g){
S.g <- diag(N[g]) - lambda_T[t] * W[[g]] %>% as.matrix()
Y.g <- Y[[g]]
XX.g <- cbind(X[[g]], W[[g]]%*%X[[g]])
l.g <- rep(1, N[g])
a.g <- alpha_T[t-1]
beta <- beta_T[t,]
ep.g <- S.g %*% Y.g - XX.g %*% beta - l.g*a.g
return(t(ep.g)%*%ep.g)
}) %>% sum()
sigma2_T[t] <- rinvgamma(1, (k_0 + sum(N))/2, (v_0+ sum_ep.gTep.g)/2)
# THE SAMPLING OF ALPHA_G FROM PROSTERIOR DISTRIBUTION
sigma2 <- sigma2_T[t]
l.g <- rep(1, N[g])
S.g <- diag(N[g]) - lambda_T[t] * W[[g]] %>% as.matrix()
Y.g <- Y[[g]]
beta <- beta_T[t,]
cbind(X[[g]], W[[g]]%*%X[[g]])
R.g <- (A_0^-1 + sigma2^-1 * t(l.g) %*% l.g) ^-1
a.g_hat <- R.g * (A_0^-1 * a_0 + sigma2^-1 * t(l.g)%*%(S.g%*%Y.g-XX.g%*%beta))
alpha_T[t, ] <- rnorm(76, a.g_hat, R.g)
}
posterior_result <- list()
posterior_result$alpha_mean <- sapply(1:76, function(g){mean(alpha_T[,g])})
posterior_result$alpha_sd <- sapply(1:76, function(g){sd(alpha_T[,g])})
posterior_result$beta_mean <- sapply(1:34, function(k){mean(beta_T[,k])})
posterior_result$beta_sd <- sapply(1:34, function(k){sd(beta_T[,k])})
posterior_result$lambda_mean <- mean(lambda_T)
posterior_result$lambda_sd <- sd(lambda_T)
posterior_result$sigma2_mean <- mean(sigma2_T)
posterior_result$sigma2_sd <- sd(sigma2_T)
var.name <- c("lambda", paste0("b1.", 1:17), paste0("b2.", 1:17), paste0("a", 1:76), "sigma2")
var.mean <- c(posterior_result$lambda_mean, posterior_result$beta_mean,
posterior_result$alpha_mean, posterior_result$sigma2_mean)
var.sd <- c(posterior_result$lambda_sd, posterior_result$beta_sd,
posterior_result$alpha_sd, posterior_result$sigma2_sd)
df <- data.frame(cbind(var.name, var.mean, var.sd))
kable(df)
# propose lambda*
for (t in 2:T){
accept = 0
if (t<2){
lambda_prime <- mvrnorm(mu = lambda_T[t-1], Sigma = 0.1^2 * diag(1))
}else if(t == 2){
lambda_prime <- mvrnorm(mu = lambda_T[t-1], Sigma = 0) * 0.95 +mvrnorm(mu = lambda_T[t-1], Sigma = 0.1^2 * diag(1)) * 0.05
}else{
lambda_prime <- mvrnorm(mu = lambda_T[t-1], Sigma = 2.38^2 * var(lambda_T[1:t-1])) * 0.95 +mvrnorm(mu = lambda_T[t-1], Sigma = 0.1^2 * diag(1)) * 0.05
}
accept = ifelse(lambda_prime >= -1/tao_G && lambda_prime <= 1/tao_G, 1, 0)
pp_l = 0
for (g in 1:76){
S_1 <- diag(N[g]) - lambda_prime * W[[g]] %>% as.matrix()
S_2 <- diag(N[g]) - lambda_T[t-1] * W[[g]] %>% as.matrix()
XX.g <- cbind(X[[g]], W[[g]]%*%X[[g]])
ep_1 <- S_1 %*% Y[[g]] - XX.g %*% beta_T[t-1, ] - rep(1, N[g]) * alpha_T[t-1, g]
ep_2 <- S_2 %*% Y[[g]] - XX.g %*% beta_T[t-1, ] - rep(1, N[g]) * alpha_T[t-1, g]
V = sigma2_T[t-1] * diag(N[g])
like_1 <- log(det(S_1)) - 0.5 * t(ep_1) %*% solve(V) %*% ep_1
like_2 <- log(det(S_2)) - 0.5 * t(ep_2) %*% solve(V) %*% ep_2
pp_l = pp_l + like_1 - like_2
}
pp_l = min(c(exp(pp_l), 1))
lambda_T[t] = ifelse(runif(1) <= pp_l, lambda_prime, lambda_T[t-1])
# THE SAMPLING OF BETA FROM PROSTERIOR DISTRIBUTION
B <- lapply(1:76, function(g){
XX.g <- cbind(X[[g]], W[[g]]%*%X[[g]])
return(t(XX.g) %*% XX.g)
})
B <- Reduce("+", B)
B <- solve(solve(B_0) + B)
beta_hat <- lapply(1:76, function(g){
sigma2 <- sigma2_T[t-1]
S.g <- diag(N[g]) - lambda_T[t] * W[[g]] %>% as.matrix()
XX.g <- cbind(X[[g]], W[[g]]%*%X[[g]])
Y.g <- Y[[g]]
l.g <- rep(1, N[g])
a.g <- alpha_T[t-1]
return(sigma2^-1 * t(XX.g) %*% (S.g%*%Y.g - l.g*a.g))
})
beta_hat <- Reduce("+", beta_hat)
beta_hat <- B %*% (solve(B_0)%*%b_0 + beta_hat)
beta_T[t,] <- mvrnorm(n=1, mu=beta_hat, Sigma=B)
# THE SAMPLING OF SIGMA_E^2 FROM PROSTERIOR DISTRIBUTION
sum_ep.gTep.g <- sapply(1:76, function(g){
S.g <- diag(N[g]) - lambda_T[t] * W[[g]] %>% as.matrix()
Y.g <- Y[[g]]
XX.g <- cbind(X[[g]], W[[g]]%*%X[[g]])
l.g <- rep(1, N[g])
a.g <- alpha_T[t-1]
beta <- beta_T[t,]
ep.g <- S.g %*% Y.g - XX.g %*% beta - l.g*a.g
return(t(ep.g)%*%ep.g)
}) %>% sum()
sigma2_T[t] <- rinvgamma(1, (k_0 + sum(N))/2, (v_0+ sum_ep.gTep.g)/2)
# THE SAMPLING OF ALPHA_G FROM PROSTERIOR DISTRIBUTION
sigma2 <- sigma2_T[t]
l.g <- rep(1, N[g])
S.g <- diag(N[g]) - lambda_T[t] * W[[g]] %>% as.matrix()
Y.g <- Y[[g]]
beta <- beta_T[t,]
cbind(X[[g]], W[[g]]%*%X[[g]])
R.g <- (A_0^-1 + sigma2^-1 * t(l.g) %*% l.g) ^-1
a.g_hat <- R.g * (A_0^-1 * a_0 + sigma2^-1 * t(l.g)%*%(S.g%*%Y.g-XX.g%*%beta))
alpha_T[t, ] <- rnorm(76, a.g_hat, R.g)
}
# propose lambda*
for (t in 2:T){
accept = 0
while (accept == 0){
if (t<2){
lambda_prime <- mvrnorm(mu = lambda_T[t-1], Sigma = 0.1^2 * diag(1))
}else if(t == 2){
lambda_prime <- mvrnorm(mu = lambda_T[t-1], Sigma = 0) * 0.95 +mvrnorm(mu = lambda_T[t-1], Sigma = 0.1^2 * diag(1)) * 0.05
}else{
lambda_prime <- mvrnorm(mu = lambda_T[t-1], Sigma = 2.38^2 * var(lambda_T[1:t-1])) * 0.95 +mvrnorm(mu = lambda_T[t-1], Sigma = 0.1^2 * diag(1)) * 0.05
}
accept = ifelse(lambda_prime >= -1/tao_G && lambda_prime <= 1/tao_G, 1, 0)
}
pp_l = 0
for (g in 1:76){
S_1 <- diag(N[g]) - lambda_prime * W[[g]] %>% as.matrix()
S_2 <- diag(N[g]) - lambda_T[t-1] * W[[g]] %>% as.matrix()
XX.g <- cbind(X[[g]], W[[g]]%*%X[[g]])
ep_1 <- S_1 %*% Y[[g]] - XX.g %*% beta_T[t-1, ] - rep(1, N[g]) * alpha_T[t-1, g]
ep_2 <- S_2 %*% Y[[g]] - XX.g %*% beta_T[t-1, ] - rep(1, N[g]) * alpha_T[t-1, g]
V = sigma2_T[t-1] * diag(N[g])
like_1 <- log(det(S_1)) - 0.5 * t(ep_1) %*% solve(V) %*% ep_1
like_2 <- log(det(S_2)) - 0.5 * t(ep_2) %*% solve(V) %*% ep_2
pp_l = pp_l + like_1 - like_2
}
pp_l = min(c(exp(pp_l), 1))
lambda_T[t] = ifelse(runif(1) <= pp_l, lambda_prime, lambda_T[t-1])
# THE SAMPLING OF BETA FROM PROSTERIOR DISTRIBUTION
B <- lapply(1:76, function(g){
XX.g <- cbind(X[[g]], W[[g]]%*%X[[g]])
return(t(XX.g) %*% XX.g)
})
B <- Reduce("+", B)
B <- solve(solve(B_0) + B)
beta_hat <- lapply(1:76, function(g){
sigma2 <- sigma2_T[t-1]
S.g <- diag(N[g]) - lambda_T[t] * W[[g]] %>% as.matrix()
XX.g <- cbind(X[[g]], W[[g]]%*%X[[g]])
Y.g <- Y[[g]]
l.g <- rep(1, N[g])
a.g <- alpha_T[t-1]
return(sigma2^-1 * t(XX.g) %*% (S.g%*%Y.g - l.g*a.g))
})
beta_hat <- Reduce("+", beta_hat)
beta_hat <- B %*% (solve(B_0)%*%b_0 + beta_hat)
beta_T[t,] <- mvrnorm(n=1, mu=beta_hat, Sigma=B)
# THE SAMPLING OF SIGMA_E^2 FROM PROSTERIOR DISTRIBUTION
sum_ep.gTep.g <- sapply(1:76, function(g){
S.g <- diag(N[g]) - lambda_T[t] * W[[g]] %>% as.matrix()
Y.g <- Y[[g]]
XX.g <- cbind(X[[g]], W[[g]]%*%X[[g]])
l.g <- rep(1, N[g])
a.g <- alpha_T[t-1]
beta <- beta_T[t,]
ep.g <- S.g %*% Y.g - XX.g %*% beta - l.g*a.g
return(t(ep.g)%*%ep.g)
}) %>% sum()
sigma2_T[t] <- rinvgamma(1, (k_0 + sum(N))/2, (v_0+ sum_ep.gTep.g)/2)
# THE SAMPLING OF ALPHA_G FROM PROSTERIOR DISTRIBUTION
sigma2 <- sigma2_T[t]
l.g <- rep(1, N[g])
S.g <- diag(N[g]) - lambda_T[t] * W[[g]] %>% as.matrix()
Y.g <- Y[[g]]
beta <- beta_T[t,]
cbind(X[[g]], W[[g]]%*%X[[g]])
R.g <- (A_0^-1 + sigma2^-1 * t(l.g) %*% l.g) ^-1
a.g_hat <- R.g * (A_0^-1 * a_0 + sigma2^-1 * t(l.g)%*%(S.g%*%Y.g-XX.g%*%beta))
alpha_T[t, ] <- rnorm(76, a.g_hat, R.g)
}
