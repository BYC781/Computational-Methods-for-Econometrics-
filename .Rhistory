library(ISLR2)
getwd()
df<-read.csv('HousingData.csv')
?lm
model1<-lm(y~NO, data = df)
summary(model1)
model2<-lm(y~ num_rooms +over25000 +built_before_1940, data = df)
summary(model2)
model3 <- lm(y ~., data = df)
summary(model3)
model4 <- lm(y ~tax_per_million, data = df)
summary(model4)
getwd()
setwd("C:/Users/chieh/Documents/ECON-7218")
set.seed(7218)
library(evd)
b1 <- 0.5; b2 <- -0.5; n =400
x1 <- rnorm(n, 0, 1)
x2 <- rchisq(n, 1)
u1 <- rgumbel(n)
u2 <- rgumbel(n)
y <- as.numeric((x1 + u1) > (x2 + u2))
loglik <- function(beta1, beta2){
index <- beta1*x1 - beta2 * x2
sum(y*(index - log(1+exp(index))) - (1-y)* log(1+exp(index)))
}
beta1_grid <- seq(from = -5, to = 5, by = 0.5)
beta2_grid <- seq(from = -5, to = 5, by = 0.5)
max_lik <- -1000
argmax_beta <- c(0,0)
for (i in beta1_grid){
for(j in beta2_grid){
temp <- loglik(i,j)
if (temp >= max_lik){
max_lik <- temp
argmax_beta <- c(i,j)
}
}
}
argmax_beta
beta1_grid <- seq(from = -5, to = 5, by = 0.5)
beta2_grid <- seq(from = -5, to = 5, by = 0.5)
max_lik <- -1000
argmax_beta <- c(0,0)
for (i in beta1_grid){
for(j in beta2_grid){
temp <- loglik(i,j)
if (temp >= max_lik){
max_lik <- temp
argmax_beta <- c(i,j)
}
}
}
argmax_beta
View(loglik)
beta1_grid <- seq(from = -5, to = 5, by = 0.5)
beta2_grid <- seq(from = -5, to = 5, by = 0.5)
max_lik <- -1000
argmax_beta <- c(0,0)
for (i in beta1_grid){
for(j in beta2_grid){
temp <- loglik(i,j)
if (temp >= max_lik){
max_lik <- temp
argmax_beta <- c(i,j)
print(max_lik)
print(argmax_beta)
}
}
}
loglik(0.5, -0.5)
loglik(1, 1)
##### grid search #####
beta1_grid <- seq(from = -5, to = 5, by = 0.5)
beta2_grid <- seq(from = -5, to = 5, by = 0.5)
max_lik <- -10000000
argmax_beta <- c(0,0)
for (i in beta1_grid){
for(j in beta2_grid){
temp <- loglik(i,j)
if (temp >= max_lik){
max_lik <- temp
argmax_beta <- c(i,j)
}
}
}
argmax_beta
set.seed(1234)
library(evd)
## R=1, N=400
b1 <- 0.5; b2 <- -0.5; n =400
x1 <- rnorm(n, 0, 1)
x2 <- rchisq(n, 1)
u1 <- rgumbel(n)
u2 <- rgumbel(n)
# construct y
y <- as.numeric((x1 + u1) > (x2 + u2))
beta1_grid <- seq(from = -5, to = 5, by = 0.5)
beta2_grid <- seq(from = -5, to = 5, by = 0.5)
max_lik <- -10000000
argmax_beta <- c(0,0)
for (i in beta1_grid){
for(j in beta2_grid){
temp <- loglik(i,j)
if (temp >= max_lik){
max_lik <- temp
argmax_beta <- c(i,j)
}
}
}
argmax_beta
loglik(0.5, -0.5)
loglik(1,1)
loglik <- function(beta1, beta2){
index <- beta1*x1 + beta2 * x2
sum(y*(index - log(1+exp(index))) - (1-y)* log(1+exp(index)))
}
beta1_grid <- seq(from = -5, to = 5, by = 0.5)
beta2_grid <- seq(from = -5, to = 5, by = 0.5)
max_lik <- -10000000
argmax_beta <- c(0,0)
for (i in beta1_grid){
for(j in beta2_grid){
temp <- loglik(i,j)
if (temp >= max_lik){
max_lik <- temp
argmax_beta <- c(i,j)
}
}
}
argmax_beta
beta1_grid <- seq(from = -5, to = 5, by = 0.1)
beta2_grid <- seq(from = -5, to = 5, by = 0.1)
max_lik <- -10000000
argmax_beta <- c(0,0)
for (i in beta1_grid){
for(j in beta2_grid){
temp <- loglik(i,j)
if (temp >= max_lik){
max_lik <- temp
argmax_beta <- c(i,j)
}
}
}
argmax_beta
beta1_grid <- seq(from = -5, to = 5, by = 0.01)
beta2_grid <- seq(from = -5, to = 5, by = 0.01)
max_lik <- -10000000
argmax_beta <- c(0,0)
for (i in beta1_grid){
for(j in beta2_grid){
temp <- loglik(i,j)
if (temp >= max_lik){
max_lik <- temp
argmax_beta <- c(i,j)
}
}
}
argmax_beta
u1
x1
library(dplyr)
df <- readxl::read_xlsx('cps09mar.xlsx')
df$married <- ifelse(df$marital %in% c(1, 2, 3), 1, 0)
blk_wm_midwest <- df %>%
filter(race==2, region == 2, female == 1)
blk_wm_midwest_logit <- glm(married ~ age + I(age^2) + education, family = binomial, data = blk_wm_midwest)
coef(blk_wm_midwest_logit) ## coef
summary(blk_wm_midwest_logit)$coefficients[,2] ## std. error
summary(blk_wm_midwest_logit)$coefficients[,1:2] ## std. error
##################### q2-2 #####################
# 設定 Bootstrap 樣本的大小和重複次數
n <- nrow(blk_wm_midwest)
B <- 1000
# 創建一個空矩陣來保存 Bootstrap 標準誤
se_boot_vec <- matrix(NA, nrow=B, ncol=4)
# 進行 Bootstrap
for (i in 1:B) {
# 從原始資料集中隨機取樣 n 個觀察值
sample_idx <- sample(1:n, size = n, replace = TRUE)
sample_data <- blk_wm_midwest[sample_idx, ]
# 使用取樣的資料跑logit
fit <- glm(married ~ age + I(age^2) + education, data = sample_data, family = binomial())
# 提取sd
for(j in 1:4){
se_boot_vec[i,j] <- summary(fit)$coefficients[j, 2]
}
}
# 計算 Bootstrap 標準誤
se_boot <- apply(se_boot_vec, 2, sd)
# 印出 Bootstrap 標準誤
se_boot
summary(blk_wm_midwest_logit)$coefficients[,1:2] ## coef and std. error
beta_hat <- coef(blk_wm_midwest_logit)
result <- - beta_hat[2] / (2 * beta_hat[3])
# 計算偏導數
d1 <- -1 / (2 * beta_hat[3])
d2 <- beta_hat[2] / (2 * beta_hat[3]^2)
# 計算標準誤
vcov_matrix <- vcov(blk_wm_midwest_logit)
delta_se <- sqrt(d1^2 * vcov_matrix[2,2] + d2^2 * vcov_matrix[3,3] + 2 * d1 * d2 * vcov_matrix[2,3])
# 輸出結果
unname(delta_se)
B <- 1000
# 儲存 Bootstrap 估計量的向量
t_boot <- numeric(B)
# 執行 Bootstrap
for (i in 1:B) {
# 從原始資料集中抽樣，構建 Bootstrap 樣本
sample_data_boot <- blk_wm_midwest[sample(nrow(blk_wm_midwest), replace = TRUE), ]
# 在 Bootstrap 樣本上擬合迴歸模型
fit_boot <- glm(married ~ age + I(age^2) + education, data = sample_data_boot, family = binomial())
# 取得迴歸係數
coef_boot <- coef(fit_boot)
# 計算 Bootstrap 估計量
t_boot[i] <- -coef_boot[2] / (2 * coef_boot[3])
}
# 計算 Bootstrap 估計量的標準差
se_boots <- sd(t_boot)
# 印出 Bootstrap 標準差
cat("Bootstrap standard error is", se_boots, "\n")
B <- 1000
# 儲存 Bootstrap 估計量的向量
t_boot <- numeric(B)
# 執行 Bootstrap
for (i in 1:B) {
# 從原始資料集中抽樣，構建 Bootstrap 樣本
sample_data_boot <- blk_wm_midwest[sample(nrow(blk_wm_midwest), replace = TRUE), ]
# 在 Bootstrap 樣本上擬合迴歸模型
fit_boot <- glm(married ~ age + I(age^2) + education, data = sample_data_boot, family = binomial())
# 取得迴歸係數
coef_boot <- coef(fit_boot)
# 計算 Bootstrap 估計量的樣本標準差 for each i
t_boot[i] <- sd(-coef_boot[2] / (2 * coef_boot[3]))
}
# 計算 Bootstrap 估計量的標準差
se_boots <- t_boot / sqrt(B)
# 印出 Bootstrap 標準差
cat("Bootstrap standard error is", se_boots, "\n")
B <- 1000
# 儲存 Bootstrap 估計量的向量
t_boot <- numeric(B)
# 執行 Bootstrap
for (i in 1:B) {
# 從原始資料集中抽樣，構建 Bootstrap 樣本
sample_data_boot <- blk_wm_midwest[sample(nrow(blk_wm_midwest), replace = TRUE), ]
# 在 Bootstrap 樣本上擬合迴歸模型
fit_boot <- glm(married ~ age + I(age^2) + education, data = sample_data_boot, family = binomial())
# 取得迴歸係數
coef_boot <- coef(fit_boot)
# 計算 Bootstrap 估計量
t_boot[i] <- -coef_boot[2] / (2 * coef_boot[3])
}
# 計算 Bootstrap 估計量的標準差
sqrt(sum(t_boot - mean(t_boot))/ (B-1))
se_boots <- sd(t_boot)
# 印出 Bootstrap 標準差
cat("Bootstrap standard error is", se_boots, "\n")
# 輸出結果
unname(delta_se)
t_boot
mean(t_boot)
t_boot - mean(t_boot)
# 計算 Bootstrap 估計量的標準差
sqrt(sum((t_boot - mean(t_boot))^2)/ (B-1))
# 印出 Bootstrap 標準差
cat("Bootstrap standard error is", se_boots, "\n")
library(multiwayvcov)
library(lmtest)
# Artificial balanced panel data set from Petersen (2009)
# https://www.kellogg.northwestern.edu/faculty/petersen/htm/papers/standarderror.html
# for illustrating and benchmarking clustered standard errors.
data(petersen)
m1 <- lm(y ~ x, data = petersen)
summary(m1)
##################### q2-1 #####################
library(dplyr)
df <- readxl::read_xlsx('cps09mar.xlsx')
df$married <- ifelse(df$marital %in% c(1, 2, 3), 1, 0)
blk_wm_midwest <- df %>%
filter(race==2, region == 2, female == 1)
blk_wm_midwest_logit <- glm(married ~ age + I(age^2) + education, family = binomial, data = blk_wm_midwest)
summary(blk_wm_midwest_logit)$coefficients[,1:2] ## coef. and std. error
##################### q2-2 #####################
# 設定 Bootstrap 樣本的大小和重複次數
n <- nrow(blk_wm_midwest)
B <- 1000
# 創建一個空矩陣來保存 Bootstrap 標準誤
se_boot_vec <- matrix(NA, nrow=B, ncol=4)
# 進行 Bootstrap
for (i in 1:B) {
# 從原始資料集中隨機取樣 n 個觀察值
sample_idx <- sample(1:n, size = n, replace = TRUE)
sample_data <- blk_wm_midwest[sample_idx, ]
# 使用取樣的資料跑logit
fit <- glm(married ~ age + I(age^2) + education, data = sample_data, family = binomial())
# 提取sd
for(j in 1:4){
se_boot_vec[i,j] <- summary(fit)$coefficients[j, 2]
}
}
# 計算 Bootstrap 標準誤
se_boot <- apply(se_boot_vec, 2, sd)
# 印出 Bootstrap 標準誤
se_boot
# 計算 - (b1) / (2*b2) 的值
beta_hat <- coef(blk_wm_midwest_logit)
beta_hat
result <- - beta_hat[2] / (2 * beta_hat[3])
result
result <- - beta_hat[2] / (2 * beta_hat[3]) %>% unname()
result
result <- - unname(beta_hat[2] / (2 * beta_hat[3]))
result
beta_hat[2] / (2 * beta_hat[3]) %>% unname()
result <- - beta_hat[2] / (2 * beta_hat[3]) %>% unname()
result
result = - beta_hat[2] / (2 * beta_hat[3]) %>% unname()
result
result <- unname(- beta_hat[2] / (2 * beta_hat[3]))
result
# 計算標準誤
vcov_matrix <- vcov(blk_wm_midwest_logit)
delta_se <- sqrt(d1^2 * vcov_matrix[2,2] + d2^2 * vcov_matrix[3,3] + 2 * d1 * d2 * vcov_matrix[2,3])
# 輸出結果
unname(delta_se)
result
?sd
choose(63)
choose(6,3)
choose(10,5)
1/252
0.04/0.025
1.96*0.025
1.96+0.049
1.96-0.049
0.09*0.09
0.09/4
-0.04 / 0.0225
qt(0.975, 15)
c(1.96-2.13*(0.09/4),1.96+2.13*(0.09/4) )
qt(0.05, 15)
(0.72 *0.28) / 100
((0.72 *0.28) / 100)^0.5
1.96* ((0.72 *0.28) / 100)^0.5
0.72-0.08800378
0.72+0.08800378
138/200
1.96* ((0.69 *0.31) / 200)^0.5
0.69 + 0.06409829
0.69 - 0.06409829
---
title: "PS1"
set.seed(3232)
library(evd)
library(dplyr)
cat('The standard error of beta1_hat is', sd(beta_seq[,1]), 'The standard error of beta1_hat is', sd(beta_seq[,2]))
library(dplyr)
df <- readxl::read_xlsx('cps09mar.xlsx')
df$married <- ifelse(df$marital %in% c(1, 2, 3), 1, 0)
blk_wm_midwest <- df %>%
filter(race==2, region == 2, female == 1)
blk_wm_midwest_logit <- glm(married ~ age + I(age^2) + education, family = binomial, data = blk_wm_midwest)
summary(blk_wm_midwest_logit)$coefficients[,1:2] ## coef. and std. error
# 設定 Bootstrap 樣本的大小和重複次數
n <- nrow(blk_wm_midwest)
B <- 1000
# 創建一個空矩陣來保存 Bootstrap 標準誤
se_boot_vec <- matrix(NA, nrow=B, ncol=4)
# 進行 Bootstrap
for (i in 1:B) {
# 從原始資料集中隨機取樣 n 個觀察值
sample_idx <- sample(1:n, size = n, replace = TRUE)
sample_data <- blk_wm_midwest[sample_idx, ]
# 使用取樣的資料跑logit
fit <- glm(married ~ age + I(age^2) + education, data = sample_data, family = binomial())
# 提取se
for(j in 1:4){
se_boot_vec[i,j] <- summary(fit)$coefficients[j, 2]
}
}
# 計算 Bootstrap 標準誤
se_boot <- apply(se_boot_vec, 2, sd)
# 印出 Bootstrap 標準誤
se_boot
# 設定 Bootstrap 樣本的大小和重複次數
n <- nrow(blk_wm_midwest)
B <- 1000
# 創建一個空矩陣來保存 Bootstrap 標準誤
se_boot_vec <- matrix(NA, nrow=B, ncol=4)
# 進行 Bootstrap
for (i in 1:B) {
# 從原始資料集中隨機取樣 n 個觀察值
sample_idx <- sample(1:n, size = n, replace = TRUE)
sample_data <- blk_wm_midwest[sample_idx, ]
# 使用取樣的資料跑logit
fit <- glm(married ~ age + I(age^2) + education, data = sample_data, family = binomial())
# 提取se
for(j in 1:4){
se_boot_vec[i,j] <- summary(fit)$coefficients[j, 2]
}
}
# 計算 Bootstrap 標準誤
se_boot <- apply(se_boot_vec, 2, sd)
# 印出 Bootstrap 標準誤
cat('Intercept', se_boot[1], '\n',
'age', se_boot[2], '\n',
"I(age^2)", se_boot[3], '\n',
"education", se_boot[4])
se_boot
# 設定 Bootstrap 樣本的大小和重複次數
n <- nrow(blk_wm_midwest)
B <- 1000
# 創建一個空矩陣來保存 Bootstrap 標準誤
se_boot_vec <- matrix(NA, nrow=B, ncol=4)
# 進行 Bootstrap
for (i in 1:B) {
# 從原始資料集中隨機取樣 n 個觀察值
sample_idx <- sample(1:n, size = n, replace = TRUE)
sample_data <- blk_wm_midwest[sample_idx, ]
# 使用取樣的資料跑logit
fit <- glm(married ~ age + I(age^2) + education, data = sample_data, family = binomial())
# 提取se
for(j in 1:4){
se_boot_vec[i,j] <- summary(fit)$coefficients[j, 2]
}
}
# 計算 Bootstrap 標準誤
se_boot <- apply(se_boot_vec, 2, sd)
# 印出 Bootstrap 標準誤
cat0('Intercept', se_boot[1], '\n',
'age', se_boot[2], '\n',
"I(age^2)", se_boot[3], '\n',
"education", se_boot[4])
# 設定 Bootstrap 樣本的大小和重複次數
n <- nrow(blk_wm_midwest)
B <- 1000
# 創建一個空矩陣來保存 Bootstrap 標準誤
se_boot_vec <- matrix(NA, nrow=B, ncol=4)
# 進行 Bootstrap
for (i in 1:B) {
# 從原始資料集中隨機取樣 n 個觀察值
sample_idx <- sample(1:n, size = n, replace = TRUE)
sample_data <- blk_wm_midwest[sample_idx, ]
# 使用取樣的資料跑logit
fit <- glm(married ~ age + I(age^2) + education, data = sample_data, family = binomial())
# 提取se
for(j in 1:4){
se_boot_vec[i,j] <- summary(fit)$coefficients[j, 2]
}
}
# 計算 Bootstrap 標準誤
se_boot <- apply(se_boot_vec, 2, sd)
# 印出 Bootstrap 標準誤
cat('Intercept', se_boot[1], '\n',
'age      ', se_boot[2], '\n',
"I(age^2)", se_boot[3], '\n',
"education", se_boot[4])
# 設定 Bootstrap 樣本的大小和重複次數
n <- nrow(blk_wm_midwest)
B <- 1000
# 創建一個空矩陣來保存 Bootstrap 標準誤
se_boot_vec <- matrix(NA, nrow=B, ncol=4)
# 進行 Bootstrap
for (i in 1:B) {
# 從原始資料集中隨機取樣 n 個觀察值
sample_idx <- sample(1:n, size = n, replace = TRUE)
sample_data <- blk_wm_midwest[sample_idx, ]
# 使用取樣的資料跑logit
fit <- glm(married ~ age + I(age^2) + education, data = sample_data, family = binomial())
# 提取se
for(j in 1:4){
se_boot_vec[i,j] <- summary(fit)$coefficients[j, 2]
}
}
# 計算 Bootstrap 標準誤
se_boot <- apply(se_boot_vec, 2, sd)
# 印出 Bootstrap 標準誤
cat(' Intercept',se_boot[1], '\n',
'age      ', se_boot[2], '\n',
"I(age^2) ", se_boot[3], '\n',
"education", se_boot[4])
# 計算 - (b1) / (2*b2) 的值
beta_hat <- coef(blk_wm_midwest_logit)
result <- unname(- beta_hat[2] / (2 * beta_hat[3]))
# 計算偏導數
d1 <- -1 / (2 * beta_hat[3])
d2 <- beta_hat[2] / (2 * beta_hat[3]^2)
# 計算標準誤
vcov_matrix <- vcov(blk_wm_midwest_logit)
delta_se <- sqrt(d1^2 * vcov_matrix[2,2] + d2^2 * vcov_matrix[3,3] + 2 * d1 * d2 * vcov_matrix[2,3])
# 輸出結果
unname(delta_se)
# 設定 Bootstrap 重複次數
B <- 1000
# 儲存 Bootstrap 估計量的向量
t_boot <- numeric(B)
# 執行 Bootstrap
for (i in 1:B) {
# 從原始資料集中抽樣，構建 Bootstrap 樣本
sample_data_boot <- blk_wm_midwest[sample(nrow(blk_wm_midwest), replace = TRUE), ]
# 在 Bootstrap 樣本上擬合迴歸模型
fit_boot <- glm(married ~ age + I(age^2) + education, data = sample_data_boot, family = binomial())
# 取得迴歸係數
coef_boot <- coef(fit_boot)
# 計算 Bootstrap 估計量
t_boot[i] <- -coef_boot[2] / (2 * coef_boot[3])
}
# 計算 Bootstrap 估計量的標準差
se_boots <- sd(t_boot)
# 印出 Bootstrap 標準差
cat("Bootstrap standard error is", se_boots, "\n")
