Sys.getlocale()
Sys.setlocale(category = "LC_ALL", locale = "UTF-8")
versions()
sessionInfo()
library(usethis)
install.packages(usethis)
install.packages("usethis")
library(usethis)
edit_git_config()
q()
library(swirl)
swirl()
install_course('Getting and Cleaning Data')
swirl()
library(swirl)
swirl()
sample(colors(), 2)
sample(colors(),10)
pal <- colorRamp(c('red', 'blue'))
pal
pal(0)
pal(1)
pal <- seq(0,1,len=6)
pal(seq(0,1,len=6))
p1 <- colorRampPalette(c('red', 'blue'))
p1(2)
p1(6)
0xcc
p2 <- colorRampPalette(c('red', 'yellow'))
p2(2)
p2(10)
showMe(p1(20))
View(showMe)
showMe(p2(20))
showMe(p2(2))
p1
?fun
?rgb
p3 <- colorRampPalette(c('blue', 'green'), alpha = 0.5)
p3(5)
plot(x, y, pch = 19, rgb(0, .5, .5))
plot(x, y, pch = 19, col = rgb(0, .5, .5))
plot(x, y, pch = 19, col = rgb(0, .5, .5, .3))
brewer.pal(3, 'BuGn')
cols <- brewer.pal(3, "BuGn")
showMe(cols)
colorRampPalette(cols)
pal <- colorRampPalette(cols
)
showMe(pal(3))
showMe(pal(20))
image(valcano, col = pal(20))
image(volcano, col = pal(20))
image(volcano, col = p1(20))
library(swirl)
swirl()
library(swirl)
swirl()
dim(pm0)
head(pm0)
cnames
cnames <- strsplit(cnames, |, fixed =TRUE)
cnames <- strsplit(cnames, '|', fixed =TRUE)
cnames
names(pm0) <- cnames[[1]][wcol]
names(pm0) <- make.names(cnames[[1]][wcol])
head(pm0)
x0 <- pm0$Sample.Value
str(x0)
mean(ix.na(x0))
mean(is.na(x0))
names(pm1) <- make.names(cnames[[1]][wcol])
dim(pm1)
x1 <- pm1$Sample.Value
mean(is.na(x1))
summary(x0)
summay*x1
summary(x1)
boxplot(x0, x1)
boxplot(log10(x0), log10(x1)
)
negative <- x1<0
sum(negative, na.rm = TRUE)
mean(negative, na.rm = TRUE)
dates <- pm1$Date
str(dates)
dates <- as.Date(as.character(dates), '%Y%m%d')
head(dates)
hist(dates[negative], 'month')
str(site0)
intersect(site0)
intersect(site0,site1)
both <- intersect(site0, site1)
botht
both
head(pm0)
cnt0 <- subset(pm0, County.Code == 36, county.site %in% both)
cnt0 <- subset(pm0, County.Code == 36 & county.site %in% both)
cnt0 <- subset(pm0, State.Code == 36 & county.site %in% both)
cnt0 <- subset(pm1, State.Code == 36 & county.site %in% both)
cnt0 <- subset(pm0, State.Code == 36 & county.site %in% both)
cnt1 <- subset(pm1, State.Code == 36 & county.site %in% both)
sapply(split(cnt0, cnt0$county.site), nrow)
sapply(split(cnt1, cnt1$county.site), ncol)
sapply(split(cnt1, cnt1$county.site), nrow)
pm0sub <- subset(cnt0, County.Code ==63 & Site.ID ==2008)
pm1sub <- subset(cnt1, County.Code ==63 & Site.ID ==2008)
x0sub <- pm0sub$Sample.Value
x1sub <- pm1sub$Sample.Value
dates0 <- as.Date(as.character(pm0sub$Date), '%Y%m%d')
dates1 <- as.Date(as.character(pm1sub$Date), '%Y%m%d')
par(mfrow = c(1,2), mar = c(4,4,2,1))
plot(date0, x0sub, pch =20)
plot(dates0, x0sub, pch =20)
abline(h = median(x0sub), lwd = 2, na.rm = T)
abline(h = median(x0sub,  na.rm = T), lwd = 2)
abline(h = median(x0sub, na.rm = TRUE),lwd=2)
plot(dates1, x1sub, pch =20)
abline(h = median(x1sub,  na.rm = T), lwd = 2)
abline(h = median(x1sub, na.rm = TRUE),lwd=2)
rng <- range(x0sub, x1sub, na.rm = TRUE)
rug
print(rng)
mn0 <- with(pm0, tapply(Sample.Value, State.Code, mean, na.rm=TRUE))
str(mn0)
mn1 <- with(pm1, tapply(Sample.Value, State.Code, mean, na.rm=TRUE))
str(mn1)
summary(mn0)
summary(mn1)
d0 <- data.frame(names(mn0), mean = mn0)
d0 <- data.frame(state = names(mn0), mean = mn0)
d1 <- data.frame(state = names(mn1), mean = mn1)
mrg <- merge(d0, d1, set='state')
mrg <- merge(d0, d1, by = "state")
dim(mrg)
head(mrg)
with(mrg, plot(rep(1,52), mrg[,2], xlim = c(.5,2.5)))
with(mrg, plot(rep(2,52), mrg[,3], xlim = c(.5,2.5)))
with(mrg, points(rep(2, 52), mrg[, 3]))
with(mrg, plot(rep(1,52), mrg[,2], xlim = c(.5,2.5)))
with(mrg, points(rep(2, 52), mrg[, 3]))
segments(rep(1, 52), mrg[, 2], rep(2, 52), mrg[, 3])
mrg[mrg$mean.x < mrg$mean.y]
mrg[mrg$mean.x < mrg$mean.y, ]
gc()
getwd()
read.csv('HousingData.csv')
df<-read.csv('HousingData.csv')
install.packages(ISLR2)
install.packages("ISLR2")
library(ISLR2)
data <- read.csv("HousingData.csv")
lm.fit <- lm(y ~., data = data)
summary(lm.fit)
source("~/house.R")
source("~/house.R")
source("~/house.R")
source("~/house.R")
summary(lm.fit)
source("~/house.R")
source("~/house.R")
source("~/house.R")
library(ISLR2)
getwd()
df<-read.csv('HousingData.csv')
?lm
model1<-lm(y~NO, data = df)
summary(model1)
model2<-lm(y~ num_rooms +over25000 +built_before_1940, data = df)
summary(model2)
model3 <- lm(y ~., data = df)
summary(model3)
model4 <- lm(y ~tax_per_million, data = df)
summary(model4)
getwd()
setwd("C:/Users/chieh/Documents/ECON-7218")
set.seed(7218)
library(evd)
b1 <- 0.5; b2 <- -0.5; n =400
x1 <- rnorm(n, 0, 1)
x2 <- rchisq(n, 1)
u1 <- rgumbel(n)
u2 <- rgumbel(n)
y <- as.numeric((x1 + u1) > (x2 + u2))
loglik <- function(beta1, beta2){
index <- beta1*x1 - beta2 * x2
sum(y*(index - log(1+exp(index))) - (1-y)* log(1+exp(index)))
}
beta1_grid <- seq(from = -5, to = 5, by = 0.5)
beta2_grid <- seq(from = -5, to = 5, by = 0.5)
max_lik <- -1000
argmax_beta <- c(0,0)
for (i in beta1_grid){
for(j in beta2_grid){
temp <- loglik(i,j)
if (temp >= max_lik){
max_lik <- temp
argmax_beta <- c(i,j)
}
}
}
argmax_beta
beta1_grid <- seq(from = -5, to = 5, by = 0.5)
beta2_grid <- seq(from = -5, to = 5, by = 0.5)
max_lik <- -1000
argmax_beta <- c(0,0)
for (i in beta1_grid){
for(j in beta2_grid){
temp <- loglik(i,j)
if (temp >= max_lik){
max_lik <- temp
argmax_beta <- c(i,j)
}
}
}
argmax_beta
View(loglik)
beta1_grid <- seq(from = -5, to = 5, by = 0.5)
beta2_grid <- seq(from = -5, to = 5, by = 0.5)
max_lik <- -1000
argmax_beta <- c(0,0)
for (i in beta1_grid){
for(j in beta2_grid){
temp <- loglik(i,j)
if (temp >= max_lik){
max_lik <- temp
argmax_beta <- c(i,j)
print(max_lik)
print(argmax_beta)
}
}
}
loglik(0.5, -0.5)
loglik(1, 1)
##### grid search #####
beta1_grid <- seq(from = -5, to = 5, by = 0.5)
beta2_grid <- seq(from = -5, to = 5, by = 0.5)
max_lik <- -10000000
argmax_beta <- c(0,0)
for (i in beta1_grid){
for(j in beta2_grid){
temp <- loglik(i,j)
if (temp >= max_lik){
max_lik <- temp
argmax_beta <- c(i,j)
}
}
}
argmax_beta
set.seed(1234)
library(evd)
## R=1, N=400
b1 <- 0.5; b2 <- -0.5; n =400
x1 <- rnorm(n, 0, 1)
x2 <- rchisq(n, 1)
u1 <- rgumbel(n)
u2 <- rgumbel(n)
# construct y
y <- as.numeric((x1 + u1) > (x2 + u2))
beta1_grid <- seq(from = -5, to = 5, by = 0.5)
beta2_grid <- seq(from = -5, to = 5, by = 0.5)
max_lik <- -10000000
argmax_beta <- c(0,0)
for (i in beta1_grid){
for(j in beta2_grid){
temp <- loglik(i,j)
if (temp >= max_lik){
max_lik <- temp
argmax_beta <- c(i,j)
}
}
}
argmax_beta
loglik(0.5, -0.5)
loglik(1,1)
loglik <- function(beta1, beta2){
index <- beta1*x1 + beta2 * x2
sum(y*(index - log(1+exp(index))) - (1-y)* log(1+exp(index)))
}
beta1_grid <- seq(from = -5, to = 5, by = 0.5)
beta2_grid <- seq(from = -5, to = 5, by = 0.5)
max_lik <- -10000000
argmax_beta <- c(0,0)
for (i in beta1_grid){
for(j in beta2_grid){
temp <- loglik(i,j)
if (temp >= max_lik){
max_lik <- temp
argmax_beta <- c(i,j)
}
}
}
argmax_beta
beta1_grid <- seq(from = -5, to = 5, by = 0.1)
beta2_grid <- seq(from = -5, to = 5, by = 0.1)
max_lik <- -10000000
argmax_beta <- c(0,0)
for (i in beta1_grid){
for(j in beta2_grid){
temp <- loglik(i,j)
if (temp >= max_lik){
max_lik <- temp
argmax_beta <- c(i,j)
}
}
}
argmax_beta
beta1_grid <- seq(from = -5, to = 5, by = 0.01)
beta2_grid <- seq(from = -5, to = 5, by = 0.01)
max_lik <- -10000000
argmax_beta <- c(0,0)
for (i in beta1_grid){
for(j in beta2_grid){
temp <- loglik(i,j)
if (temp >= max_lik){
max_lik <- temp
argmax_beta <- c(i,j)
}
}
}
argmax_beta
u1
x1
library(dplyr)
df <- readxl::read_xlsx('cps09mar.xlsx')
df$married <- ifelse(df$marital %in% c(1, 2, 3), 1, 0)
blk_wm_midwest <- df %>%
filter(race==2, region == 2, female == 1)
blk_wm_midwest_logit <- glm(married ~ age + I(age^2) + education, family = binomial, data = blk_wm_midwest)
coef(blk_wm_midwest_logit) ## coef
summary(blk_wm_midwest_logit)$coefficients[,2] ## std. error
summary(blk_wm_midwest_logit)$coefficients[,1:2] ## std. error
##################### q2-2 #####################
# 設定 Bootstrap 樣本的大小和重複次數
n <- nrow(blk_wm_midwest)
B <- 1000
# 創建一個空矩陣來保存 Bootstrap 標準誤
se_boot_vec <- matrix(NA, nrow=B, ncol=4)
# 進行 Bootstrap
for (i in 1:B) {
# 從原始資料集中隨機取樣 n 個觀察值
sample_idx <- sample(1:n, size = n, replace = TRUE)
sample_data <- blk_wm_midwest[sample_idx, ]
# 使用取樣的資料跑logit
fit <- glm(married ~ age + I(age^2) + education, data = sample_data, family = binomial())
# 提取sd
for(j in 1:4){
se_boot_vec[i,j] <- summary(fit)$coefficients[j, 2]
}
}
# 計算 Bootstrap 標準誤
se_boot <- apply(se_boot_vec, 2, sd)
# 印出 Bootstrap 標準誤
se_boot
summary(blk_wm_midwest_logit)$coefficients[,1:2] ## coef and std. error
beta_hat <- coef(blk_wm_midwest_logit)
result <- - beta_hat[2] / (2 * beta_hat[3])
# 計算偏導數
d1 <- -1 / (2 * beta_hat[3])
d2 <- beta_hat[2] / (2 * beta_hat[3]^2)
# 計算標準誤
vcov_matrix <- vcov(blk_wm_midwest_logit)
delta_se <- sqrt(d1^2 * vcov_matrix[2,2] + d2^2 * vcov_matrix[3,3] + 2 * d1 * d2 * vcov_matrix[2,3])
# 輸出結果
unname(delta_se)
B <- 1000
# 儲存 Bootstrap 估計量的向量
t_boot <- numeric(B)
# 執行 Bootstrap
for (i in 1:B) {
# 從原始資料集中抽樣，構建 Bootstrap 樣本
sample_data_boot <- blk_wm_midwest[sample(nrow(blk_wm_midwest), replace = TRUE), ]
# 在 Bootstrap 樣本上擬合迴歸模型
fit_boot <- glm(married ~ age + I(age^2) + education, data = sample_data_boot, family = binomial())
# 取得迴歸係數
coef_boot <- coef(fit_boot)
# 計算 Bootstrap 估計量
t_boot[i] <- -coef_boot[2] / (2 * coef_boot[3])
}
# 計算 Bootstrap 估計量的標準差
se_boots <- sd(t_boot)
# 印出 Bootstrap 標準差
cat("Bootstrap standard error is", se_boots, "\n")
B <- 1000
# 儲存 Bootstrap 估計量的向量
t_boot <- numeric(B)
# 執行 Bootstrap
for (i in 1:B) {
# 從原始資料集中抽樣，構建 Bootstrap 樣本
sample_data_boot <- blk_wm_midwest[sample(nrow(blk_wm_midwest), replace = TRUE), ]
# 在 Bootstrap 樣本上擬合迴歸模型
fit_boot <- glm(married ~ age + I(age^2) + education, data = sample_data_boot, family = binomial())
# 取得迴歸係數
coef_boot <- coef(fit_boot)
# 計算 Bootstrap 估計量的樣本標準差 for each i
t_boot[i] <- sd(-coef_boot[2] / (2 * coef_boot[3]))
}
# 計算 Bootstrap 估計量的標準差
se_boots <- t_boot / sqrt(B)
# 印出 Bootstrap 標準差
cat("Bootstrap standard error is", se_boots, "\n")
B <- 1000
# 儲存 Bootstrap 估計量的向量
t_boot <- numeric(B)
# 執行 Bootstrap
for (i in 1:B) {
# 從原始資料集中抽樣，構建 Bootstrap 樣本
sample_data_boot <- blk_wm_midwest[sample(nrow(blk_wm_midwest), replace = TRUE), ]
# 在 Bootstrap 樣本上擬合迴歸模型
fit_boot <- glm(married ~ age + I(age^2) + education, data = sample_data_boot, family = binomial())
# 取得迴歸係數
coef_boot <- coef(fit_boot)
# 計算 Bootstrap 估計量
t_boot[i] <- -coef_boot[2] / (2 * coef_boot[3])
}
# 計算 Bootstrap 估計量的標準差
sqrt(sum(t_boot - mean(t_boot))/ (B-1))
se_boots <- sd(t_boot)
# 印出 Bootstrap 標準差
cat("Bootstrap standard error is", se_boots, "\n")
# 輸出結果
unname(delta_se)
t_boot
mean(t_boot)
t_boot - mean(t_boot)
# 計算 Bootstrap 估計量的標準差
sqrt(sum((t_boot - mean(t_boot))^2)/ (B-1))
# 印出 Bootstrap 標準差
cat("Bootstrap standard error is", se_boots, "\n")
